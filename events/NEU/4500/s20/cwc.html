<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>C with Classes</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9660;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Software Development</a></td></tr></table></div><div class="tocviewsublistonly" style="display: block;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="abstract.html" class="tocviewlink" data-pltdoc="x">Abstract</a></td></tr><tr><td align="right"></td><td><a href="general.html" class="tocviewlink" data-pltdoc="x">General</a></td></tr><tr><td align="right"></td><td><a href="schedule.html" class="tocviewlink" data-pltdoc="x">Schedule</a></td></tr><tr><td align="right"></td><td><a href="readings.html" class="tocviewlink" data-pltdoc="x">Readings</a></td></tr><tr><td align="right"></td><td><a href="lab.html" class="tocviewlink" data-pltdoc="x">Lab Book</a></td></tr><tr><td align="right"></td><td><a href="projects.html" class="tocviewlink" data-pltdoc="x">Assignments, Overview</a></td></tr><tr><td align="right"></td><td><a href="make.html" class="tocviewlink" data-pltdoc="x">&#8212;<wbr></wbr>Make</a></td></tr><tr><td align="right"></td><td><a href="reviews.html" class="tocviewlink" data-pltdoc="x">&#8212;<wbr></wbr>Reviews</a></td></tr><tr><td align="right"></td><td><a href="projects2.html" class="tocviewlink" data-pltdoc="x">Assignments, Actual</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x">C with Classes</a></td></tr></table></div></div></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.5</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="projects2.html" title="backward to &quot;Assignments, Actual&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Software Development&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div><h3><a name="(part._cwc)"></a>C with Classes</h3><p><span class="refelem"><span class="refcolumn"><span class="refcontent"><img src="readme.png" alt="don't" width="52" height="38"/></span></span></span></p><p><div class="SIntrapara">&#8220;C with Classes&#8221;  (<span style="font-style: italic">CwC</span>) is a dialect of C++ 2011 used in this course.
CwC has three main goals:
</div><div class="SIntrapara"><ul><li><p>be easy to learn for Java developers: to that end, CwC encourages
a programming style that emphasizes class-based programming with
dynamic dispatch,</p></li><li><p>expose developers to manual memory management: students are faced
with design choices between stack and heap allocation and must
be hygenic in their use of memory, </p></li><li><p>act as a style guide to ease sharing code among teams:
by removing choices, CwC makes it easier to write anonymous
code.</p></li></ul></div></p><p>We do <span style="color: red">not</span> aim to teach C++ (other classes do) or teach low-level or
systems&rsquo; programming (other classes do that). CwC is a vehicle for exploring
interesting problems in software design in the presence of finite resources.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>C++ supports separate compilation, the code that implements
classes would normally be in independent <span class="stt">.cpp</span> files compiled
independently of one another. While CwC will not scale to large code bases
where compile times are substantial, it should serve us well enough.</p></blockquote></blockquote></blockquote><p><span style="font-weight: bold">Files:</span> A CwC program consists of one <span class="stt">.cpp</span> file and multiple
<span class="stt">.h</span> files.  Each file should start with a comment that documents the
language used, <span class="stt">//lang::CwC</span> for files written in the subset described
here, and <span class="stt">//lang::Cpp</span> files written in C++11.  All
<a href="https://devdocs.io/c">C library functions</a> are available.</p><p><span style="font-weight: bold">Congruences:</span> Any feature syntactically and semantically congruent to
Java is available in CwC. This includes control structures (<span class="stt">if-then</span>,
<span class="stt">for</span>, <span class="stt">while</span>, <span class="stt">switch</span>, <span class="stt">break</span>, <span class="stt">return</span>) and primitive
types (<span class="stt">int</span>, <span class="stt">char</span>, <span class="stt">long</span>, <span class="stt">double</span>, <span class="stt">float</span>, <span class="stt">short</span>,
<span class="stt">bool</span>).  Modifiers <span class="stt">unsigned</span>, <span class="stt">long</span>, <span class="stt">extern</span> and <span class="stt">static</span>
can be used.} The type <span class="stt">size_t</span> is an alias for unsigned long
(<span style="font-style: italic">i.e.</span>  64-bit) values.</p><p><span style="font-weight: bold">Arrays:</span> Arrays in CwC have a simple representation: a sequence of
values allocated contiguously in memory. Arrays can be allocated in the
heap, on the stack, or within another data type. An example of a heap
allocated array that is accessed by a pointer to the first element is shown
next:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">*</span><span class="RktMeta">ia</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">int</span><span class="RktPn">[</span><span class="RktVal">20</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">//</span><span class="hspace">&nbsp;</span><span class="RktCmt">allocate</span><span class="hspace">&nbsp;</span><span class="RktCmt">an</span><span class="hspace">&nbsp;</span><span class="RktCmt">array</span><span class="hspace">&nbsp;</span><span class="RktCmt">of</span><span class="hspace">&nbsp;</span><span class="RktCmt">20</span><span class="hspace">&nbsp;</span><span class="RktCmt">integers</span><span class="hspace">&nbsp;</span><span class="RktCmt">on</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">heap</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The consequence of this simple representation is that the length of an array
isn&rsquo;t recorded for us. This, in turn, means that it&rsquo;s the programmer&rsquo;s
responsibility to keep track of the bounds of an array. Reading or writing
outside of an array&rsquo;s bounds means potentially accessing memory that is not
owned by our program. There are no "out of bounds" exceptions, it is simply
*undefined behavior* and can lead to nasty bugs.
Array elements are indexed from 0 and are accessed similarly to Java:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">20</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">[</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">30</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">[</span><span class="RktVal">2</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">[</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Another style of accessing array elements uses pointer arithmetic:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktPn">*</span><span class="RktMeta">ia</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">20</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">++</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">*</span><span class="RktMeta">ia</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">30</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">++</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">*</span><span class="RktMeta">ia</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">*</span><span class="RktPn">(</span><span class="RktMeta">ia</span><span class="RktPn">-</span><span class="RktVal">2</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">*</span><span class="RktPn">(</span><span class="RktMeta">ia</span><span class="RktPn">-</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The code uses <span class="stt">*ia</span> to "derefence" the pointer, that is to tell the
compiler to write, <span style="font-style: italic">e.g.</span> 20, into the location pointed by <span class="stt">ia</span>.
On the first line it is <span class="stt">ia[0]</span>, then <span class="stt">ia[1]</span>, etc.  We can also write
<span class="stt">*(ia-1</span>) to request the "previous" value.</p><p>A heap-allocated array can be freed using &lsquo;delete[]&lsquo; (note the square
brackets):</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">delete</span><span class="RktPn">[</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>An array can be allocated on the stack, in this case we would write"</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">[</span><span class="RktVal">20</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">20</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">[</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">30</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">[</span><span class="RktVal">2</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">ia</span><span class="RktPn">[</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>In this case the array needs not be deleted (in fact you can&rsquo;t) as it will
be reclaimed when the function where the definition occurs returns.</p><p>Lastly, one can declare an array as part of an enclosing data structure.
The following is a string class for strings that can have at most 10
characters:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">class</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">char</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">val_</span><span class="RktPn">[</span><span class="RktVal">11</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktPn">(</span><span class="RktMeta">char</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">c</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">assert</span><span class="RktPn">(</span><span class="RktMeta">strlen</span><span class="RktPn">(</span><span class="RktMeta">c</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">&lt;=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">strcpy</span><span class="RktPn">(</span><span class="RktPn">&amp;</span><span class="RktMeta">val_</span><span class="RktPn">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">c</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The field <span class="stt">val_</span> is an array of 10 characters that is created each time a
<span class="stt">String</span> object is created and delete when the string is deleted. The
constructor makes sure that the argument string is not too long and copies
it in the array by passing its address to <span class="stt">strcpy</span>.</p><p>To manipulate a group of objects, says strings, one can either define an
<span style="font-style: italic">array of strings</span> or an <span style="font-style: italic">an array of pointer to strings</span>.
There are reasons for picking one or the other depending on the application.
Imagine that we wanted to create an array of 10 strings, and query the size
of the array&rsquo;s first element:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">as1</span><span class="RktPn">[</span><span class="RktVal">10</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">as1</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">.</span><span class="RktMeta">size</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">as2</span><span class="RktPn">[</span><span class="RktVal">10</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">as2</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">as2</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">-</span><span class="RktPn">&gt;</span><span class="RktMeta">size</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">as3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktPn">[</span><span class="RktVal">10</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">as3</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">.</span><span class="RktMeta">size</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktPn">*</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">as4</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktPn">*</span><span class="RktPn">[</span><span class="RktVal">10</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">as4</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">as4</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">-</span><span class="RktPn">&gt;</span><span class="RktMeta">size</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The above code give four variants. <span class="stt">as1</span> is a stack-allocated array of
strings. The strings are initialized with their default constructor.
<span class="stt">as2</span> is a stack-allocated array of pointer. We must create the object
and set a pointer to it in the array. <span class="stt">as3</span> is a pointer to an array of
objects. The array and the objects it contains is heap-allocated in one go.
Finally, <span class="stt">as4</span> is a pointer to a heap-allocated array of pointers.</p><p><div class="SIntrapara">To choose one of these alternative one must answer the following questions:
</div><div class="SIntrapara"><ul><li><p>Is the array of a fixed size or may it have to grow? Fixed-sized
solutions are <span class="stt">as1</span> and <span class="stt">as2</span>.</p></li><li><p>Will the array only hold String instances, or is it possible that
we need to store subclasses?  If we need to store subclasses then
use pointers, <span class="stt">as2</span> or <span class="stt">as4</span>.</p></li><li><p>Can some of the String be <span class="stt">nullptr</span>?  If yes, the use pointers,
<span class="stt">as2</span> or <span class="stt">as4</span>.</p></li><li><p>Should the array outlive the current function? If yes, then use
heap-allocation, <span class="stt">as3</span> or <span class="stt">as4</span>.</p></li><li><p>May the array have to be shared wit  other parts of the system?
If yes, then use heap-allocation, <span class="stt">as3</span> or <span class="stt">as4</span>.</p></li><li><p>Should the strings in the array be shared with other parts of
the system?  If yes, use pointers to strings, <span class="stt">as2</span> or <span class="stt">as4</span>.</p></li></ul></div></p><p><span style="font-weight: bold">C strings:</span> are defined as an array of characters terminated with a
special character &rsquo;\0&rsquo;. To compute the length of a string:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">size_t</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">length</span><span class="RktPn">(</span><span class="RktMeta">char</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">p</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">size_t</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">len</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">while</span><span class="RktPn">(</span><span class="RktMeta">p</span><span class="RktPn">[</span><span class="RktMeta">len</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">!=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'\0'</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">len</span><span class="RktPn">++</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">return</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">len</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Traditionally, the length does not count the trailing terminator. Thus a
string is constructed by allocating memory for the number of characters
that it should hold plus one. The empty string is a character array of
length one. To create the string <span class="stt">Hi</span> one could write:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">size_t</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">len</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">2</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">char</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">c</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">char</span><span class="RktPn">[</span><span class="RktMeta">len</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">+</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">c</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'H'</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">c</span><span class="RktPn">[</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'i'</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">c</span><span class="RktPn">[</span><span class="RktVal">2</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'\0'</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>Lastly, string literals, <span style="font-style: italic">i.e.</span> string constants written <span class="stt">"hi"</span>
have type <span class="stt">const char*</span> to make obvious that they should not modified.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">const</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">char</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">c</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">"hi"</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">c</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'H'</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">//</span><span class="hspace">&nbsp;</span><span class="RktCmt">not</span><span class="hspace">&nbsp;</span><span class="RktCmt">allowed</span><span class="hspace">&nbsp;</span><span class="RktCmt">by</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">compiler</span></td></tr><tr><td><span class="RktCmt"></span><span class="RktMeta">char</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">no</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">const_cast</span><span class="RktPn">&lt;</span><span class="RktMeta">char</span><span class="RktPn">*</span><span class="RktPn">&gt;</span><span class="RktPn">(</span><span class="RktMeta">c</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">no</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">'H'</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">//</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktCmt">allowed</span><span class="hspace">&nbsp;</span><span class="RktCmt">but</span><span class="hspace">&nbsp;</span><span class="RktCmt">will</span><span class="hspace">&nbsp;</span><span class="RktCmt">cause</span><span class="hspace">&nbsp;</span><span class="RktCmt">an</span><span class="hspace">&nbsp;</span><span class="RktCmt">error</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The above code block, declares a variable <span class="stt">c</span> that refers to a constant
string <span class="stt">hi</span>. Trying to change the first letter of <span class="stt">c</span> to an upper case
<span class="stt">H</span> is caught by the C++ compiler. One can cast the <span class="stt">const</span> away, but
the program will likely stop with an access violation if you try to modify
the string literal as they are stored in read-only memory.  If you really
need to change a literal string, copy it (<span style="font-style: italic">e.g.</span> with <span class="stt">strdup()</span>).</p><p><span style="font-weight: bold">Allocation and deallocation:</span> To allocate a value on the heap, use the
<span class="stt">new</span> operator, and to deallocate use <span class="stt">delete</span>.  Calling <span class="stt">delete</span>
on a <span class="stt">nullptr</span> does nothing. The <span class="stt">delete[]</span> operator is used for
arrays, it deletes every element of the array, and calls their destructor,
before freeing the array itself.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">char</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">c1</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">char</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">char</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">c2</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">char</span><span class="RktPn">[</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">//</span><span class="hspace">&nbsp;</span><span class="RktCmt">same</span><span class="hspace">&nbsp;</span><span class="RktCmt">as</span><span class="hspace">&nbsp;</span><span class="RktCmt">above</span></td></tr><tr><td><span class="RktCmt"></span><span class="RktMeta">char</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">c3</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">char</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">//</span><span class="hspace">&nbsp;</span><span class="RktCmt">meaningless.</span><span class="hspace">&nbsp;</span><span class="RktCmt">Don't</span></td></tr><tr><td><span class="RktCmt"></span><span class="RktMeta">2DPoint</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">p</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">2DPoint</span><span class="RktPn">(</span><span class="RktVal">0</span><span class="RktPn">,</span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">//</span><span class="hspace">&nbsp;</span><span class="RktCmt">a</span><span class="hspace">&nbsp;</span><span class="RktCmt">single</span><span class="hspace">&nbsp;</span><span class="RktCmt">point</span></td></tr><tr><td><span class="RktCmt"></span><span class="RktMeta">2DPoint</span><span class="RktPn">*</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">arr</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">2DPoint</span><span class="RktPn">*</span><span class="RktPn">[</span><span class="RktVal">10</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">//</span><span class="hspace">&nbsp;</span><span class="RktCmt">an</span><span class="hspace">&nbsp;</span><span class="RktCmt">array</span><span class="hspace">&nbsp;</span><span class="RktCmt">of</span><span class="hspace">&nbsp;</span><span class="RktCmt">10</span><span class="hspace">&nbsp;</span><span class="RktCmt">pointers</span><span class="hspace">&nbsp;</span><span class="RktCmt">to</span><span class="hspace">&nbsp;</span><span class="RktCmt">points</span><span class="RktMeta"></span></td></tr></table></blockquote><p><span style="font-weight: bold">Stack v. Heap:</span> Values can be allocated on the heap (via <span class="stt">new</span>) or
on the stack.  The main difference is that a stack allocated value will be
automatically deallocated when the current function returns.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">f</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">s1</span><span class="RktPn">(</span><span class="RktVal">"hi"</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">s0</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">String</span><span class="RktPn">(</span><span class="RktVal">"hi"</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">return</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">s0</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The function <span class="stt">f</span> creates two string objects, one is stack allocated and
will be destructed when the function returns, the other is heap allocated
and will continue to exist after the funtion returns. It would be an error
to try to <span class="stt">return</span> s1}. In fact the compiler would prevent that.</p><p>Heap allocated object are typically references through pointer variables.
To get to a field or method, we must use the arrow operator (<span style="font-style: italic">e.g</span>
<span class="stt">s0-&gt;size_</span> or <span class="stt">s0-&gt;size()</span>).</p><p>Stack allocated objects are access by reference and we use the dot operator
(<span style="font-style: italic">e.g.</span> <span class="stt">s1.size_</span> or <span class="stt">s1.size()</span>.  The compiler will remind
you when you forget.</p><p><span style="font-weight: bold">Pointers v. References</span> Each value is stored at some particular
location in memory. When we need to talk about a memory location we can use
a <span style="font-style: italic">pointer</span> (<span class="stt">*</span>) or a <span style="font-style: italic">reference</span> (<span class="stt">&amp;</span>). There are a
number of design choices linked to the two. The compiler creates references
by telling us where a particular value starts in memory. To get a reference
you must have a value, thus a reference can never be <span class="stt">nullptr</span>. A pointer
on the other hand, can be <span class="stt">nullptr</span>.  A reference, if it denotes a local
variable, will become invalid as soon as the function where the variable
resides returns. This will lead us to a programming style where pointers are
used for values that may outlast a call, values whose lifetime must be
thought about carefully. On the other hand, references will be used with
values that are on loan to a function and should not be retained.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">void</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">recall</span><span class="RktPn">(</span><span class="RktMeta">String</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">s</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">cache_</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">s</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta">void</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">read</span><span class="RktPn">(</span><span class="RktMeta">String</span><span class="RktPn">&amp;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">s</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">len_</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">s</span><span class="RktPn">.</span><span class="RktMeta">size</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The first function, <span class="stt">recall</span>, gets a pointer to a string and stores it
into a field. The second function, <span class="stt">read</span>, gets a reference to a string
uses it to call a method but does not retain the object.</p><p><span style="font-weight: bold">Assert</span> The <span class="stt">assert()</span> function is useful to check that the state
of the program is as expected. The following function checks that its first
argument is not a <span class="stt">nullptr</span> and that the second argument is larger than
10. If either failes, the program will stop.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">void</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">larger_than_ten</span><span class="RktPn">(</span><span class="RktMeta">char</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">s</span><span class="RktPn">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">size_t</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">len</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">assert</span><span class="RktPn">(</span><span class="RktMeta">s</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">&amp;&amp;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">len</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">&gt;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">10</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p><span style="font-weight: bold">Classes:</span> CwC classes use a subset of the C++ syntax and features.
A CwC class has a name, a parent class, zero or more fields, one or more
constructors, a destructor, zero or more methods.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">class</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">ClassName</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">public</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">ParentName</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">public</span><span class="RktPn">:</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">fields</span><span class="RktPn">.</span><span class="RktPn">.</span><span class="RktPn">.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">constructors</span><span class="RktPn">.</span><span class="RktPn">.</span><span class="RktPn">.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">destructor</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">methods</span><span class="RktPn">.</span><span class="RktPn">.</span><span class="RktPn">.</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The keyword <span class="stt">public</span> on the parent and before the methods and fields is
used to ensure that all declarations are accessible to other classes in the
project. Note the semi-colon after the closing brace, if you don&rsquo;t the
compiler will remind you.</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">/**</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta">2DPoint</span><span class="hspace">&nbsp;</span><span class="RktMeta">represents</span><span class="hspace">&nbsp;</span><span class="RktMeta">two</span><span class="hspace">&nbsp;</span><span class="RktMeta">dimensional</span><span class="hspace">&nbsp;</span><span class="RktMeta">coordinates</span><span class="hspace">&nbsp;</span><span class="RktMeta">with</span><span class="hspace">&nbsp;</span><span class="RktMeta">a</span><span class="hspace">&nbsp;</span><span class="RktMeta">pair</span><span class="hspace">&nbsp;</span><span class="RktMeta">of</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta">integer</span><span class="hspace">&nbsp;</span><span class="RktMeta">variables.</span><span class="hspace">&nbsp;</span><span class="RktMeta">2DPoints</span><span class="hspace">&nbsp;</span><span class="RktMeta">are</span><span class="hspace">&nbsp;</span><span class="RktMeta">immutable.</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">*</span><span class="hspace">&nbsp;</span><span class="RktMeta">author:</span><span class="hspace">&nbsp;</span><span class="RktMeta">jo@husky.neu.edu</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">*/</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">class</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">2DPoint</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">public</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">Object</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">public</span><span class="RktPn">:</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">x_</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">//</span><span class="hspace">&nbsp;</span><span class="RktCmt">x</span><span class="hspace">&nbsp;</span><span class="RktCmt">coordinate</span></td></tr><tr><td><span class="RktCmt"></span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">y_</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">//</span><span class="hspace">&nbsp;</span><span class="RktCmt">y</span><span class="hspace">&nbsp;</span><span class="RktCmt">coordinate</span></td></tr><tr><td><span class="RktCmt"></span><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">/**</span><span class="hspace">&nbsp;</span><span class="RktMeta">Default</span><span class="hspace">&nbsp;</span><span class="RktMeta">constructor</span><span class="hspace">&nbsp;</span><span class="RktMeta">initializes</span><span class="hspace">&nbsp;</span><span class="RktMeta">point</span><span class="hspace">&nbsp;</span><span class="RktMeta">to</span><span class="hspace">&nbsp;</span><span class="RktMeta">the</span><span class="hspace">&nbsp;</span><span class="RktMeta">origin</span><span class="hspace">&nbsp;</span><span class="RktMeta">*/</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">2DPoint</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">Object</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">x_</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">y_</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">/**</span><span class="hspace">&nbsp;</span><span class="RktMeta">Initializing</span><span class="hspace">&nbsp;</span><span class="RktMeta">constructor.</span><span class="hspace">&nbsp;</span><span class="RktMeta">*/</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">2DPoint</span><span class="RktPn">(</span><span class="RktMeta">int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">x</span><span class="RktPn">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">Object</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktPn">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">x_</span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">)</span><span class="RktPn">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">y_</span><span class="RktPn">(</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">/**</span><span class="hspace">&nbsp;</span><span class="RktMeta">Initializing</span><span class="hspace">&nbsp;</span><span class="RktMeta">constructor.</span><span class="hspace">&nbsp;</span><span class="RktMeta">*/</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">2DPoint</span><span class="RktPn">(</span><span class="RktMeta">2DPoint</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">&amp;</span><span class="RktMeta">p</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">Object</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">x_</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">p</span><span class="RktPn">.</span><span class="RktMeta">x_</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">y_</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">p</span><span class="RktPn">.</span><span class="RktMeta">y_</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">/**</span><span class="hspace">&nbsp;</span><span class="RktMeta">Destructor</span><span class="hspace">&nbsp;</span><span class="RktMeta">*/</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">~</span><span class="RktMeta">2DPoint</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">/**</span><span class="hspace">&nbsp;</span><span class="RktMeta">Getter</span><span class="hspace">&nbsp;</span><span class="RktMeta">for</span><span class="hspace">&nbsp;</span><span class="RktMeta">x</span><span class="hspace">&nbsp;</span><span class="RktMeta">*/</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">virtual</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">get_x</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">return</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">x_</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">/**</span><span class="hspace">&nbsp;</span><span class="RktMeta">Getter</span><span class="hspace">&nbsp;</span><span class="RktMeta">for</span><span class="hspace">&nbsp;</span><span class="RktMeta">y</span><span class="hspace">&nbsp;</span><span class="RktMeta">*/</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">virtual</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">get_x</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">return</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">y_</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The above is an example of class declaration for an immutable point class.
The getter methods are declared virtual to allow subclasses to override them
if need be. The third constructor takes a reference to another point (rather
than a pointer) to emphasize that it does not retain that object. The
destructor is not marked <span class="stt">virtual</span> because we assume the parent class did
that for us.</p><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>There is another reason for not declaring multiple variables in
one line: <span class="stt">char* c,d;</span> is equivalent to <span class="stt">char* c:</span> and <span class="stt">char d;</span>.
This is part of the C legacy.</p></blockquote></blockquote></blockquote><p><span style="font-weight: bold">Fields:</span> Fields are declared by giving a type name and a field name.
Do not declare multiple fields on the same line as it makes it harder to
write comments for each of them.</p><p><span style="font-weight: bold">Constructors:</span> A class may have multiple constructors. A constructor
should initialize all the fields of a class. Unlike in Java, fields are not
initialize to zero in C++. Unintialized fields can hold random values and
can cause surprising bugs.  A constructor consists of the name of the
class followed by arguments, then it can invoke the parent constructor,
field initializers and have a block of code.  For example here is a
constructor for a color point:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta">class</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">2DColorPoint</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">public</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">2DPoint</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">public</span><span class="RktPn">:</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">char</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">col_</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktCmt">//</span><span class="hspace">&nbsp;</span><span class="RktCmt">owned;</span><span class="hspace">&nbsp;</span><span class="RktCmt">the</span><span class="hspace">&nbsp;</span><span class="RktCmt">color</span><span class="hspace">&nbsp;</span><span class="RktCmt">of</span><span class="hspace">&nbsp;</span><span class="RktCmt">this</span><span class="hspace">&nbsp;</span><span class="RktCmt">point</span></td></tr><tr><td><span class="RktCmt"></span><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">/**</span><span class="hspace">&nbsp;</span><span class="RktMeta">Constructor</span><span class="hspace">&nbsp;</span><span class="RktMeta">*/</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">2DColorPoint</span><span class="RktPn">(</span><span class="RktMeta">int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">x</span><span class="RktPn">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">y</span><span class="RktPn">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">char</span><span class="RktPn">*</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">color</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">:</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">2DPoint</span><span class="RktPn">(</span><span class="RktMeta">x</span><span class="RktPn">,</span><span class="RktMeta">y</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">assert</span><span class="RktPn">(</span><span class="RktMeta">color</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">!=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">nullptr</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">size_t</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">len</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">strlen</span><span class="RktPn">(</span><span class="RktMeta">color</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">col_</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">new</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">char</span><span class="RktPn">[</span><span class="RktMeta">len</span><span class="RktPn">+</span><span class="RktVal">1</span><span class="RktPn">]</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">strcpy</span><span class="RktPn">(</span><span class="RktMeta">col_</span><span class="RktPn">,</span><span class="RktMeta">color</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p>The parent constructor can be left out, in which case the default
constructor will be invoked.  Fields can be either initialized in the
constructor&rsquo;s body or with field initializers after the colon.</p><p><span style="font-weight: bold">Destructor:</span> There is a single destructor per class. It can be
declared <span class="stt">virtual</span> if the class will have subclasses. The destructor is
run whenever an object is <span class="stt">delete</span>d or goes out of scope. The destructor
should delete all owned data and finalize any external resources owned by
the object.</p><p><span style="font-weight: bold">Methods:</span> are declared by giving the keyword <span class="stt">virtual</span>, the type of
the return value (or <span class="stt">void</span>) the name of the method, a list of arguments
and a body. Multiple methods of the same name but with different argument
types are allowed (this is call overloading). The <span class="stt">virtual</span> keyword can
be omitted if we are redefining a method.</p><p><span style="font-weight: bold">Casts:</span> We will <span class="stt">dynamic_cast</span> to check that an object is a
subclass of a type, <span class="stt">static_cast</span> for casts that are always safe,
<span class="stt">reinterpret_cast</span> and <span class="stt">const_cast</span> in exceptional situations.</p><p><span style="font-weight: bold">Including files:</span> The <span class="stt">#include</span> directive tells the compiler to
copy the specified file in the current file.  Included files are found in
the current directory (<span class="stt">#include "helper.h"</span>) or looked up in the C++
distribution (<span class="stt">#include &lt;assert.h&gt;</span>). Note that we suggest using C-style
standard header names inside <span class="stt">#include</span> (e. g. <span class="stt">assert.h</span> instead of
<span class="stt">cassert</span>) because that guarantees it is in the global namespace.
To avoid including the same file multiple times, start every .h-file with
<span class="stt">#pragma once</span>.</p><p><span style="font-weight: bold">The main function:</span> The entry point of a CwC program is the <span class="stt">main</span>
function. This function takes two arguments: the number of command line
arguments (by convenction called <span class="stt">argc</span>), and an array of strings with
the actual arguments (by convention <span class="stt">argv</span>). Note, that the first element
of the argument array, <span class="stt">argv[0]</span>, is the executable used to invoke the
program. Actual command-line arguments &ndash; if any &ndash; start at <span class="stt">argv[1]</span>.</p><p>Example:</p><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="RktMeta">#</span><span class="RktMeta">include</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">&lt;</span><span class="RktMeta">stdio</span><span class="RktPn">.</span><span class="RktMeta">h</span><span class="RktPn">&gt;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta">&#160;</span></td></tr><tr><td><span class="RktMeta"></span><span class="RktMeta">int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">main</span><span class="RktPn">(</span><span class="RktMeta">int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">argc</span><span class="RktPn">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">char</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">*</span><span class="RktPn">*</span><span class="RktMeta">argv</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">if</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">argc</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">==</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">)</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta">return</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">printf</span><span class="RktPn">(</span><span class="RktVal">"Program</span><span class="hspace">&nbsp;</span><span class="RktVal">invoked</span><span class="hspace">&nbsp;</span><span class="RktVal">as:</span><span class="hspace">&nbsp;</span><span class="RktVal">%s\n"</span><span class="RktPn">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">argv</span><span class="RktPn">[</span><span class="RktVal">0</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">printf</span><span class="RktPn">(</span><span class="RktVal">"Additional</span><span class="hspace">&nbsp;</span><span class="RktVal">arguments:\n"</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">for</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">(</span><span class="RktMeta">int</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">i</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">=</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">1</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">i</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktPn">&lt;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">argc</span><span class="RktPn">;</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">i</span><span class="RktPn">++</span><span class="RktPn">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">printf</span><span class="RktPn">(</span><span class="RktVal">"</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktVal">%s\n"</span><span class="RktPn">,</span><span class="RktMeta"></span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktMeta">argv</span><span class="RktPn">[</span><span class="RktMeta">i</span><span class="RktPn">]</span><span class="RktPn">)</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="hspace">&nbsp;&nbsp;</span><span class="RktMeta">return</span><span class="hspace">&nbsp;</span><span class="RktMeta"></span><span class="RktVal">0</span><span class="RktPn">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="RktPn">}</span><span class="RktMeta"></span></td></tr></table></blockquote><p><span style="font-weight: bold">Anti-features:</span>
The following are not going to be used in CwC.</p><ul><li><p>Multiple inheritance: a class can have only one parent in CwC.</p></li><li><p>Separate compilation: we limit CwC to having a single <span class="stt">.cpp</span> file.</p></li><li><p><span class="stt">private:</span> and <span class="stt">protected:</span> access modifiers: All CwC methods, fields, and parents are declared public, the <span class="stt">friend</span> declaration is not used.</p></li><li><p>Templates and macros: are not used. For global constant, we will use
static variables.</p></li><li><p>Operator overloading: is not used.</p></li><li><p><span class="stt">auto</span> declaration</p></li><li><p>Iterators</p></li><li><p>Move and copy constructors</p></li><li><p><span class="stt">using</span>, <span class="stt">namespace</span></p></li><li><p>Override</p></li><li><p>Exceptions, try, catch</p></li><li><p>C++ standard library classes</p></li><li><p>C-style <span class="stt">struct</span> declaration are replaced with classes,
C-style memory managemnt, <span style="font-style: italic">e.g.</span> <span class="stt">malloc</span>, <span class="stt">free</span>,
is replace with <span class="stt">new</span> and <span class="stt">delete</span>.</p></li><li><p>Lambdas are not used (they can be replaced with objects).</p></li><li><p>Nested classes</p></li><li><p>Optional function arguments</p></li><li><p>...</p></li></ul><p>Towards the end of the class, we will evaluate the impact of these choices
on your code and identify the features that would be most useful to
incorporate in your code base.</p><p><span style="font-weight: bold"><span style="color: red">Errata:</span></span> The function <span class="stt">length</span> was incorrect, it returned a
result off by one. There was an error in the allocation of an array of
object poointers: <span class="stt">2DPoint[10]</span> instead of <span class="stt">2DPoint*[10]</span>. Fixed.</p><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="projects2.html" title="backward to &quot;Assignments, Actual&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="index.html" title="up to &quot;Software Development&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<span class="nonavigation">next &rarr;</span></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>