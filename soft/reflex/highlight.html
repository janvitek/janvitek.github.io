<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Untitled Document</title><style type="text/css"><!--.style1 {	font-family: Arial, Helvetica, sans-serif;	font-size: small;}.style2 {font-family: Arial, Helvetica, sans-serif; font-size: x-small; }--></style></head><body><h1>New Programming Model for Real-time Computing</h1><p><strong><em>Josh Auerbach, David Bacon, Jesper Honig Spring, and Jan Vitek</em></strong></p><p class="style1">Real-time programming is an emerging area of importance, but  real-time systems are growing more complex, making Java™ an attractive platformfor building large mixed-mode real-time systems. Mixed-mode real-time systems  are application where some components must react in a timely manner while other  have no constraints on their execution time, examples of such applications  can be found in domains ranging from market data systems on Wall Street to  scientific codes on satellites. The challenge is how to integrate real-time  tasks which require sub-millisecond response times with components that have  not been written to abide with any real-time constraints. While commercial  products such as IBM's WebSphere  Real-Time solves some of the integration problems with the help of novel Real-time  Garbage Collection techniques, there is still a class of highly demanding tasks  that needs better response times.</p><p class="style1">The Flexible Task Graph, or FlexoTask, programming model provides  a single programming model for  very low latencies real-time programming. This model uses static  analysis to enforce restrictions, so that programs are guaranteed  to meet the restrictions. This contrasts with the Real-Time Specification for  Java, whose NoHeapRealtimeThread relies on dynamic checking, meaning that extensive  testing is required in order to be relatively assured that a program will always  meet the restrictions. </p><p align="center"><img src="flexo.jpg" alt="FlexoTask" width="500" /><br />  </p><p align="center" class="style2">Fig. 1 The Flexible Task Graph Development environment running  under Eclipse.</p><p align="left" class="style1"><strong>How does it work?</strong><br />  During development, the Eclipse-based editor and builder monitors the Java  language restrictions to ensure that they are being adhered to. The main restrictions  concern the use of static storage, although, for performance-critical applications,  there are optional restrictions on allocating objects and synchronization.  Upon compilation, the Eclipse-based builder rewrites some Java bytecodes to  support some Flexible Task Graph features. When the program is executed, the  Java VM (virtual machine) checks all the bytecodes for safe enforcement of  all of the restrictions. Thereafter, a Flexible Task Graph runs in a privileged,  high-priority thread that is exempt from being paused by system activities  such as garbage collection and JIT (just-in-time) compilation. The programming    model gives each task in the Flexible Task Graph a private memory area that    is optionally divided into a heap  and a transient area. Communication between    tasks can be by deep copy     or by reference.    Communication between the task graph and the rest of the Java application    can be through a restricted form of object sharing  or    by using transactional methods. The model supports the addition of pluggable    schedulers, pluggable &quot;distributors&quot; (for  crossing machine boundaries), and pluggable instrumentation. Through the use  of <a href="http://flexotask.sourceforge.net/">an open-source toolkit released  on sourceforge.net</a> along with an <a href="http://www.alphaworks.ibm.com/tech/flexotasks">alphaWorks®  release</a>, any developer can build these pluggable components, which extend  the Flexible Task Graphs system with new capabilities.</p><p align="left" class="style1">The Flexible Task Graphs open source codebase  was developed at IBM and under research agreements with IBM by Purdue and EPFL.  It is being made available under the Eclipse Public License. Flexible Task  Graphs are a unification of four previous programming models which have been  described in the following papers:</p><p class="style1"><em>Flexible task graphs: a unified restricted    thread programming model for Java</em> by Joshua Auerbach, David F. Bacon,    Rachid Guerraoui, Jesper Honig Spring, and Jan Vitek, published in <strong>LCTES    2008.</strong><br /><em>Java Takes Flight: Time-portable Real-time Programming  with Exotasks</em> by J.Auerbach,  D. F. Bacon, D. T. Iercan, C. M. Kirsch, V. T. Rajan, H. R. Roeck, and R. Trummer,  published in <strong>LCTES 2007</strong>.<br />  <em>Reflexes: abstractions for highly responsive systems</em> by J. Spring,  F. Pizlo, R. Guerraoui, and J. Vitek, published in <strong>VEE 2007.</strong><br />  <em>Streamflex: high-throughput stream programming in Java </em>by J. Spring,  J. Privat, R. Guerraoui, J. Vitek, published in <strong>OOPSLA 2007.<br />  </strong><em>Eventrons:    a Safe Programming Construct for High-frequency Hard Real-time Applications</em> by  D. Spoonhower, J. Auerbach, D. F. Bacon, P. Cheng, and D. Grove, published  in <strong>PLDI 2006</strong>.<br /></p></body></html>